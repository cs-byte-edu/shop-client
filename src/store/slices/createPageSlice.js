import api from "../../api/apiClient";

export const createPageSlice = (set, get) => ({
  pageContent: {},
  loadingPage: false,
  errorPage: null,

  loadPageContent: async (pageSlug) => {
    // Опціонально: перевірка кешу
    if (get().pageContent[pageSlug]) {
      return;
    }

    set({ loadingPage: true, errorPage: null });

    try {
      const response = await api.get(pageSlug);

      set((state) => ({
        pageContent: {
          ...state.pageContent,
          [pageSlug]: response.data.data,
        },
      }));
      // не встановлюємо loadingPage: false - це надлишково, бо loadingPage: false встановлюється в finaly
    } catch (error) {
      set({
        errorPage: error.message || "An unknown error occurred",
      });
      // Дозволяємо компоненту, що викликав, обробити помилку
      // Throw дозволяє caller'у додаткову логіку:
      // - Показати toast
      // - Редірект на 404
      // - Відправити аналітику
      // - Fallback логіка
      throw error;
    } finally {
      // Гарантовано вимикаємо індикатор завантаження в кінці
      set({ loadingPage: false });
    }
  },
});

/*

Коротка відповідь: **Так, у більшості випадків це потрібно.** `set({ errorPage: ... })` та `throw error` служать різним, хоча й пов'язаним, цілям. Вони не взаємозамінні, а доповнюють один одного.

Давайте розберемо, за що відповідає кожен із цих підходів.

---

### 1. `set({ errorPage: ... })` — Декларативне оновлення UI

Ця дія відповідає за **стан (state)** вашого додатку. Її головна мета — повідомити усім компонентам, що "підписані" на цей стан, про те, що сталася помилка.

* **Призначення:** Змінити глобальний стан, щоб UI міг на це **декларативно** відреагувати.
* **Як це працює:**
    1.  Ви викликаєте `set`, і значення `errorPage` у сторі Zustand змінюється з `null` на об'єкт помилки.
    2.  Будь-який компонент, який використовує хук `useStore(state => state.errorPage)`, автоматично отримає нове значення і запустить процес ре-рендерингу.
    3.  Цей компонент тепер може відобразити повідомлення про помилку в призначеному для цього місці.

**Приклад компонента, який покладається на `set`:**

```jsx
function PageDisplay() {
  const content = useStore(state => state.pageContent['my-page']);
  const isLoading = useStore(state => state.loadingPage);
  const error = useStore(state => state.errorPage);

  if (isLoading) {
    return <Spinner />;
  }

  // Ось тут використовується стан, встановлений через set()
  if (error) {
    return <div className="error-panel">Помилка завантаження: {error}</div>;
  }

  return <div>{content}</div>;
}
```

Цей компонент не знає, *хто* і *коли* викликав завантаження. Він просто реагує на поточний стан: завантаження, помилка або успіх.

---

### 2. `throw error` — Імперативна обробка побічних ефектів

Ця дія відповідає за **потік керування (control flow)** у коді, який ініціював процес. Вона дозволяє коду, що викликав `loadPageContent`, негайно дізнатися про невдачу і виконати якісь **імперативні** дії.

* **Призначення:** Дозволити "кол-сайту" (місцю виклику) виконати специфічну логіку у відповідь на помилку.
* **Що може робити код, який "зловив" помилку:**
    * Показати спливаюче повідомлення (toast): `toast.error('Не вдалося завантажити сторінку!');`
    * Надіслати звіт про помилку в систему моніторингу (Sentry, LogRocket): `Sentry.captureException(error);`
    * Зупинити відправку форми.
    * Виконати перенаправлення на іншу сторінку.
    * Відкотити оптимістичний UI апдейт.

**Приклад компонента, який покладається на `throw`:**

```jsx
function PageLoaderButton() {
  const loadPageContent = useStore(state => state.loadPageContent);

  const handleClick = async () => {
    try {
      await loadPageContent('my-page');
      // Цей код виконається тільки при успіху
      toast.success('Сторінку успішно завантажено!');
    } catch (error) {
      // Цей блок виконається завдяки `throw error` у вашому сторі
      toast.error('Спробуйте ще раз пізніше.');
      console.error('Local handler caught:', error);
    }
  };

  return <button onClick={handleClick}>Завантажити сторінку</button>;
}
```

---

### Висновок: Чому краще використовувати обидва підходи

Поєднуючи їх, ви отримуєте найкраще з обох світів:

1.  **`set({ errorPage: ... })`** оновлює глобальний стан, дозволяючи вашому UI декларативно відобразити постійне повідомлення про помилку в потрібному місці.
2.  **`throw error`** дозволяє компоненту, який ініціював дію, виконати негайні побічні ефекти, такі як показ тимчасових сповіщень або логування.

**Якщо ви приберете `set({ errorPage: ... })`**, то компонент `PageDisplay` ніколи не дізнається про помилку і не зможе показати `<div class="error-panel">`. Він буде вічно показувати або старий контент, або нічого.

**Якщо ви приберете `throw error`**, то `PageLoaderButton` не зможе "зловити" помилку, і його `try...catch` блок стане марним. Користувач не отримає сповіщення-тост, а ви не зможете виконати локальну логіку обробки помилки.

Тому ваша реалізація, яка використовує обидва підходи, є найбільш гнучкою, надійною і відповідає найкращим практикам розробки.
*/
